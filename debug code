/**
*
* @file ece544ip_test.c
*
* @author Neima Kashani
* @copyright Portland State University, 2016-2020
*
* This file implements a test program for the Nexys4IO and Digilent Pmod peripherals
* used in ECE 544. The peripherals provides access to the pushbuttons
* and slide switches, the LEDs, the RGB LEDs (only Nexys A7), and the Seven Segment display
* on the Digilent Nexys A7 and Basys 3 boards and the PmodOLEDrgb (94 x 64 RGB graphics display)
* and the PmodENC (rotary encoder + slide switch + pushbutton).
*
* The test is basic but covers all of the API functions:
*        o initialize the Nexys4IO, Pmod drivers and all the other peripherals
*        o Set the LED's to different values
*        o Check that the duty cycles can be set for both RGB LEDs
*        o Write character codes to the digits of the seven segment display banks
*        o Check that all of the switches and pushbuttons on the Nexys4 can be read
*        o Performs a basic test on the rotary encoder and pmodOLEDrgb
*


*
* @note
* The minimal hardware configuration for this test is a Microblaze-based system with at least 32KB of memory,
* an instance of Nexys4IO, an instance of the pmodOLEDrgb AXI slave peripheral, and instance of the pmodENC AXI
* slave peripheral, an instance of AXI GPIO, an instance of AXI timer and an instance of the AXI UARTLite 
* (used for xil_printf() console output)
*
* @note
* The driver code and test application(s) for the pmodOLDrgb and pmodENC are
* based on code provided by Digilent, Inc.
*
* @note
* This test program does not use the FIT Timer or interrupts - one less thing to worry about
******************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "platform.h"
#include "xparameters.h"
#include "xstatus.h"
#include "microblaze_sleep.h"
#include "nexys4IO.h"
#include "PmodOLEDrgb.h"
#include "PWM.h"
#include "xintc.h"
#include "xtmrctr.h"
#include "PmodENC544.h"
/************************** Constant Definitions ****************************/


// Clock frequencies
#define CPU_CLOCK_FREQ_HZ                XPAR_CPU_CORE_CLOCK_FREQ_HZ
#define AXI_CLOCK_FREQ_HZ                XPAR_CPU_M_AXI_DP_FREQ_HZ


// AXI timer parameters
#define AXI_TIMER_DEVICE_ID                XPAR_AXI_TIMER_0_DEVICE_ID
#define AXI_TIMER_BASEADDR                XPAR_AXI_TIMER_0_BASEADDR
#define AXI_TIMER_HIGHADDR                XPAR_AXI_TIMER_0_HIGHADDR
#define TmrCtrNumber                        0




// Definitions for peripheral NEXYS4IO
#define NX4IO_DEVICE_ID                XPAR_NEXYS4IO_0_DEVICE_ID
#define NX4IO_BASEADDR                XPAR_NEXYS4IO_0_S00_AXI_BASEADDR
#define NX4IO_HIGHADDR                XPAR_NEXYS4IO_0_S00_AXI_HIGHADDR




// Fixed Interval timer - 100 MHz input clock, 40KHz output clock
// FIT_COUNT_1MSEC = FIT_CLOCK_FREQ_HZ * .001
#define FIT_IN_CLOCK_FREQ_HZ		CPU_CLOCK_FREQ_HZ
#define FIT_CLOCK_FREQ_HZ			40000
#define FIT_COUNT					(FIT_IN_CLOCK_FREQ_HZ / FIT_CLOCK_FREQ_HZ)
#define FIT_COUNT_1MSEC				40
#define FIT_TRACKER_MAX				400 // Reset every 10 millisecond



// PWM
#define PWM_BASEADDR        XPAR_PWM_0_PWM_AXI_BASEADDR





#define PWM1_SWITCH_MASK    0x000F
#define PWM2_SWITCH_MASK    0x00F0









//GLOBAL VARIABLES



int Period_Global = 100*1000*20
//100 to convert from 100MHz to 1MHz, 1000 to convert to 1KHz, and 20 to convert to 50 Hz or Period 20 ms

int Debug_Mode=0;
int FIT_Handler_Switch=0;  //This global variable is just used to tell the FIT_Handler when to start and stop



void sample(int FIT_Tracker, uint16_t switchStateString){
	// Does sampling occur 0.001 seconds after change or is my math wrong?
	if((FIT_Tracker%FIT_TRACKER_MAX)==(1*(FIT_TRACKER_MAX/16)){
		if((switchStateString & SWITCH15_MASK)==SWITCH15_MASK){set_ADC_channel(UP);}
	}else if((FIT_Tracker%FIT_TRACKER_MAX)==(3*(FIT_TRACKER_MAX/16)){
		if((switchStateString & SWITCH15_MASK)==SWITCH15_MASK){UP_Data = read_ADC();}
	}else if((FIT_Tracker%FIT_TRACKER_MAX)==(5*(FIT_TRACKER_MAX/16)){
		if((switchStateString & SWITCH14_MASK)==SWITCH14_MASK){set_ADC_channel(DOWN);}
	}else if((FIT_Tracker%FIT_TRACKER_MAX)==(7*(FIT_TRACKER_MAX/16)){
		if((switchStateString & SWITCH14_MASK)==SWITCH14_MASK){DOWN_Data = read_ADC();}
	}else if((FIT_Tracker%FIT_TRACKER_MAX)==(9*(FIT_TRACKER_MAX/16)){
		if((switchStateString & SWITCH13_MASK)==SWITCH13_MASK){set_ADC_channel(LEFT);}
	}else if((FIT_Tracker%FIT_TRACKER_MAX)==(11*(FIT_TRACKER_MAX/16)){
		if((switchStateString & SWITCH13_MASK)==SWITCH13_MASK){LEFT_Data = read_ADC();}
	}else if((FIT_Tracker%FIT_TRACKER_MAX)==(13*(FIT_TRACKER_MAX/16)){
		if((switchStateString & SWITCH12_MASK)==SWITCH12_MASK){set_ADC_channel(RIGHT);}
	}else if((FIT_Tracker%FIT_TRACKER_MAX)==(15*(FIT_TRACKER_MAX/16)){
		if((switchStateString & SWITCH12_MASK)==SWITCH12_MASK){RIGHT_Data = read_ADC();}
	} else{encoderHandling();} 
}


void FIT_Handler(void){
        // This handler is used to sample to Rotary input encoder PMOD and to sample the Motor Encoder
		static int FIT_Tracker = 0;
        if(FIT_Handler_Switch==1){
			

			
			if(FIT_Tracker>FIT_TRACKER_MAX){
					FIT_Tracker=1;

			}// Frequency of resetting Reset is 100 Hz
			
			uint16_t switchStateString = NX4IO_getSwitches();
			if(debugCheck()==1){
					encoderHandling();
			}else{
				sample(FIT_Tracker,switchStateString)
			}
			FIT_Tracker=FIT_Tracker+1;
        }
}


/**************************** MAIN ROUTINE ******************************/


/****************************************************************************/
/**
* This is the main function that calls the functions that controls the outputs to the
*  7Seg Display, OLED display, and the HB3 Controller IP. The loops calls
*  the functions that handle queries to the Rotary Encoder, the
 *****************************************************************************/



int debugCheck(){
        uint16_t switchStateString = NX4IO_getSwitches();
        if(((int)(switchStateString) & (PWM1_SWITCH_MASK|PWM2_SWITCH_MASK))>0){
                return 1;
        } else {
                return 0;
        }
}




bool PWM_CALIBRATE(){
        uint16_t switchStateString = NX4IO_getSwitches();
        if(((int)(switchStateString) & (PWM1_SWITCH_MASK|PWM2_SWITCH_MASK))>0){

			PWM_Disable(PWM_BASEADDR);
			PWM_Set_Period(PWM_BASEADDR, Period_Global); 
			PWM_Set_Duty(PWM_BASEADDR, 0, 0);
			PWM_Enable(PWM_BASEADDR);
			int i =0;
			OLED_Write_Signal("i", i, 1);

			int val1=(int) ((switchStateString & PWM1_SWITCH_MASK)>>0);
			int val2=(int) ((switchStateString & PWM2_SWITCH_MASK)>>3);
			if(val1>0){PWM_Set_Duty(PWM_BASEADDR, Period_Global*(0.025+0.005*val1), 0);} // Duty Cycle between 3% and 10% 
			if(val1>1){PWM_Set_Duty(PWM_BASEADDR, Period_Global*(0.025+0.005*val2), 1);} // Duty Cycle between 3% and 10% 
			return true;
			} 
		else{
			return false;		
        } 

}








void LightFollow(){
    PWM_Set_Period(PWM_BASEADDR, Period_Global); 
	PWM_Enable(PWM_BASEADDR);
	while(1) { //While loop has a minimum period of 1 miliscond ut actually less because of calls
	if(debugCheck()==1){
		Debug_Mode=1;
        	FIT_Handler_Switch=0;
	}else{
		Debug_Mode=0;
		FIT_Handler_Switch=1;
	}    
btnvalue = NX4IO_getBtns();
    if (btnvalue == 0x10){// If Center button pressed
	PWM_CALIBRATE();
	}else{

		loopTracker=loopTracker+1;
		if (loopTracker>1001){   // Reset loop Tracker one a second
			loopTracker = 1;
		}// Ma

	if(loopTracker%100==0){  // Frequency of less than 10 Hz  
		PWM_Set_Duty(PWM_BASEADDR, 100*100*(defaultAngle_Period100us+verticle_Angle), 0);
		PWM_Set_Duty(PWM_BASEADDR, 100*100*(defaultAngle_Period100us+horizontal_Angle), 1);
	}
	if(loopTracker%100==50){ // Frequency of less than 10 Hz  
		OLED_Display_Angle();
		OLED_Display_Light_Signal();
		Light_Servo_Calculations(uint16_t signal_Top, uint16_t signal_Bottom, uint16_t signal_Left, uint16_t signal_Right);
	}
	usleep(1000);  // Sleep for milli Second
	} 
}

}

int ipow(int base, int exp){ //Efficient Power Function from internet https://stackoverflow.com/questions/101439/the-most-efficient-way-to-implement-an-integer-based-power-function-powint-int
    int result = 1;
    for (;;)
    {
        if (exp & 1)
            result *= base;
        exp >>= 1;
        if (!exp)
            break;
        base *= base;
    }

    return result;
}

// Test that this function works for negative number for value and 0 for value and "INVALID" for 10^10
void OLED_Write_Signal(char name[], int value, int row){ 
	int spaceIterator=0;
	int lineLength=11;
	int valueLength=0;
	int maxDigits=7;
	char valueString[maxDigits];
	char printString[lineLength];
	
	
	int absoluteValue=abs(value);
	
	sprintf(printString, "%i", ipow(10,lineLength-1); // Fill string with filler number

	

	int nameLength=sizeof(name)/name[0]))
	printString[0]='X';
	printString[1]='X';
	if(value<0){
		printString[2]='-';
	} else{
		printString[2]='+';
	}// Use sign as seperator


	if(nameLength==1){
		printString[0]=name[0];
	} else if((nameLength>1){
		printString[0]=name[0];
		printString[1]=name[1];
	}
	
	for(i=maxDigits-1; i>=0;i--){
		if((absoluteValue/ipow(10,i))>0){
			if(valueLength<(i+1){
				(valueLength=(i+1);
			}
			printString[3+i]=valueString[i];
		}
	}
	// The following fills out the remainder of the line with blanks to make sure extra numbers are over written
	for (i=valueLength+3;i<lineLength+1;i++){
		printString[i]=' ';
	}
	OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 1, row);	
	OLEDrgb_PutString(&pmodOLEDrgb_inst, printString);
	
}





}
