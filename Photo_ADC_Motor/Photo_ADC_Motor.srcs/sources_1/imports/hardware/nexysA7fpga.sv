// nexysA7fpga.sv - Top level module for the Nexys A7 version of the ECE 544 Getting Started project
//
// Created By:	Roy Kravitz
// Date:		26-March-2022
// Version:		2.0
//
// Description:
// ------------
// This module provides the top level for the Getting Started hardware which
// includes the Nexys A7 and no Pmods. Project #1 will add a PmodOLEDrgb and a
// a PmodENC to the system but we didn't want to hold up you working on this
// project while waiting for your Pmods to arrive.
//////////////////////////////////////////////////////////////////////




module nexysA7fpga(
    input logic         clk,			// 100Mhz clock input
    input logic         btnC,			// center pushbutton
    input logic         btnU,			// UP (North) pusbhbutton
    input logic         btnL,			// LEFT (West) pushbutton
    input logic         btnD,			// DOWN (South) pushbutton  - used for system reset
    input logic         btnR,			// RIGHT (East) pushbutton
	input logic         btnCpuReset,	// CPU reset pushbutton
    input logic [15:0]  sw,				// slide switches on Nexys 4
    output logic [15:0] led,			// LEDs on Nexys 4   
    output logic        RGB1_Blue,      // RGB1 LED (LD16) 
    output logic        RGB1_Green,
    output logic        RGB1_Red,
    output logic        RGB2_Blue,      // RGB2 LED (LD17)
    output logic        RGB2_Green,
    output logic        RGB2_Red,
    output logic [7:0]  an,             // Seven Segment display
    output logic [6:0]  seg,
    output logic        dp,             // decimal point display on the seven segment 
    
    input logic         uart_rtl_rxd,	// USB UART Rx and Tx on Nexys 4
    output logic        uart_rtl_txd,	
    
	inout logic [7:0]  JA,              // JA Pmod conector - Can be used for debugging purposes
	inout logic [7:0]  JB,              // 2 of the pins go to VCC3V3 and 2 go to ground so only 8 are actually used
	inout logic [7:0]  JC,              // 2 of the pins go to VCC3V3 and 2 go to ground so only 8 are actually used
    inout logic [7:0]  JD              // 2 of the pins go to VCC3V3 and 2 go to ground so only 8 are actually used
//      input   vauxportn1,   
//    input   vauxportp1,
//    input   vauxportn2,   
//    input   vauxportp2,
//    input   vauxportn3,   
//    input   vauxportp3,
//   input   vauxportn4,   
//    input   vauxportp4

);

// internal variables
// Clock and Reset 
logic           sysclk; 
logic           sysreset_n, sysreset;

// GPIO pins 
logic [7:0]	    gpio_in;				// embsys GPIO input port
logic [7:0]	    gpio_out;				// embsys GPIO output port

// RGB LED 
logic           w_RGB1_Red, w_RGB1_Blue, w_RGB1_Green;

// LED pins 
logic [15:0]    led_int;                // Nexys4IO drives these outputs

// make the connections to the GPIO port.  Most of the bits are unused in the Getting
// Started project but GPIO's provide a convenient way to get the inputs and
// outputs from logic you create to and from the Microblaze.  For example,
// you may decide that using an axi_gpio peripheral is a good way to interface
// your hardware pulse-width detect logic with the Microblaze.  Our application
// is simple.
// Wrap the RGB led output back to the application program for software pulse-width detect
assign gpio_in = {5'b00000, w_RGB1_Red, w_RGB1_Blue, w_RGB1_Green};

// Drive the leds from the signal generated by the microblaze 
assign led = led_int;                   // LEDs are driven by led

// make the connections
// system-wide signals
assign sysclk = clk;
assign sysreset_n = btnCpuReset;		// The CPU reset pushbutton is asserted low.  The other pushbuttons are asserted high
										// but the Microblaze for Nexys 4 expects reset to be asserted low
assign sysreset = ~sysreset_n;			// Generate a reset signal that is asserted high for any logic blocks expecting it.

// JA can be used for debug purposes
//assign JA = 8'b0000000;

    wire [15:0] ADC_Digital_Data; 
    wire ADC_ENABLE;  
    wire ADC_DATA_READY;

    
    wire p1;
    wire n1;
    wire p2;
    wire n2;
    wire p3;
    wire n3;    
    wire p4;
    wire n4;
    wire vp_wire;
    wire vn_wire;    
    
    reg [6:0] Address_in;  
    
    
    always @(posedge(clk))
        begin
            case(sw)
            0: Address_in <= 8'h11;
            1: Address_in <= 8'h12;
            2: Address_in <= 8'h13;
            3: Address_in <= 8'h14;
            endcase
        end
      

    
//    assign vauxportn1 = n1;     
//    assign vauxportp1 = p1;
//    assign vauxportn2 = n2;     
//    assign vauxportp2 = p2;    
//    assign vauxportn3 = n3;     
//    assign vauxportp3 = p3;    
//    assign vauxportn4 = n4;     
//    assign vauxportp4 = p4;

 initial begin
    led_int <= 16'b01010;
 end 

      always @( posedge(clk))
      begin            
        if(ADC_DATA_READY == 1'b1)
        begin
          case (ADC_Digital_Data[15:12])
            0:  led_int <= 16'b10101;
            1:  led_int <= 16'b101;
            2:  led_int <= 16'b111;
            3:  led_int <= 16'b1111;
            4:  led_int <= 16'b11111;
            5:  led_int <= 16'b111111;
            6:  led_int <= 16'b1111111; 
            7:  led_int <= 16'b11111111;
            8:  led_int <= 16'b111111111;
            9:  led_int <= 16'b1111111111;
            10: led_int <= 16'b11111111111;
            11: led_int <= 16'b111111111111;
            12: led_int <= 16'b1111111111111;
            13: led_int <= 16'b11111111111111;
            14: led_int <= 16'b111111111111111;
            15: led_int <= 16'b1111111111111111;                        
           default: led_int <= 16'b1; 
           endcase
        end 

          
      end
    
xadc_wiz_0  PhotoSignal_XADC (.daddr_in(Address_in), //addresses can be found in the artix 7 XADC user guide DRP register space
                     .dclk_in(clk), 
                     .den_in(ADC_ENABLE), 
                     .di_in(0), 
                     .dwe_in(0), 
                     .busy_out(),                    
                     .vauxp1(p1),
                     .vauxn1(n1),
                     .vauxp2(p2),
                     .vauxn2(n2),
                     .vauxp3(p3),
                     .vauxn3(n3),
                     .vauxp4(p4),
                     .vauxn4(n4),
                     .vn_in(vn_wire), 
                     .vp_in(vp_wire), 
                     .alarm_out(), 
                     .do_out(ADC_Digital_Data), 
                     .reset_in(0),
                     .eoc_out(ADC_ENABLE),
                     .channel_out(),
                     .drdy_out(ADC_DATA_READY));

// instantiate the embedded system
embsys EMBSYS
(
        // RGB1/2 Led's 
        .RGB1_Blue_0(RGB1_Blue),
        .RGB1_Green_0(RGB1_Green),
        .RGB1_Red_0(RGB1_Red),
        .RGB2_Blue_0(RGB2_Blue),
        .RGB2_Green_0(RGB2_Green),
        .RGB2_Red_0(RGB2_Red),
        // Seven Segment Display anode control  
        .an_0(an),
        .dp_0(dp),
        //.led_0(led_int),
        .seg_0(seg),
        // Push buttons and switches  
        .btnC_0(btnC),
        .btnD_0(btnD),
        .btnL_0(btnL),
        .btnR_0(btnR),
        .btnU_0(btnU),
        .sw_0(sw),
        // reset and clock 
        .sysreset_n(sysreset_n),
        .sysclk(sysclk),
        // UART pins 
        .uart_rtl_0_rxd(uart_rtl_rxd),
        .uart_rtl_0_txd(uart_rtl_txd),
        
        
        //PWM Generator pins  
        .PWM(JA),
        //PmodOLEDrgb pins
        .PmodOLEDrgb_out_0_pin1_i(),
        .PmodOLEDrgb_out_0_pin1_o(JB[0]),
        .PmodOLEDrgb_out_0_pin1_t(),
        .PmodOLEDrgb_out_0_pin2_i(),
        .PmodOLEDrgb_out_0_pin2_o(JB[1]),
        .PmodOLEDrgb_out_0_pin2_t(),
        .PmodOLEDrgb_out_0_pin3_i(),
        .PmodOLEDrgb_out_0_pin3_o(JB[2]),
        .PmodOLEDrgb_out_0_pin3_t(),
        .PmodOLEDrgb_out_0_pin4_i(),
        .PmodOLEDrgb_out_0_pin4_o(JB[3]),
        .PmodOLEDrgb_out_0_pin4_t(),
        //Pin5 and Pin6 do not exist
        .PmodOLEDrgb_out_0_pin7_i(),
        .PmodOLEDrgb_out_0_pin7_o(JB[4]),
        .PmodOLEDrgb_out_0_pin7_t(),
        .PmodOLEDrgb_out_0_pin8_i(),
        .PmodOLEDrgb_out_0_pin8_o(JB[5]),
        .PmodOLEDrgb_out_0_pin8_t(),
        .PmodOLEDrgb_out_0_pin9_i(),
        .PmodOLEDrgb_out_0_pin9_o(JB[6]),
        .PmodOLEDrgb_out_0_pin9_t(),
        .PmodOLEDrgb_out_0_pin10_i(),
        .PmodOLEDrgb_out_0_pin10_o(JB[7]),
        .PmodOLEDrgb_out_0_pin10_t(),
        //

        //
        //.Vaux1_v_n(vauxn1),
        //.Vaux1_v_p(vauxp1),
        //.Vaux2_v_n(vauxn2),
        //.Vaux2_v_p(vauxp2),
        //.Vaux3_v_n(vauxn3),
        //.Vaux3_v_p(vauxp3),
        //.Vaux4_v_n(vauxn4),
        //.Vaux4_v_p(vauxp4),
        
        .encA(JC[4]),     // A and B quadrature inputs from PmodENC
        .encB(JC[5]),
        .encBTN(JC[6]),   // pushbutton input from PmodENC
        .encSWT(JC[7]) 
        

);

endmodule: nexysA7fpga


